Index: scripts/units/unit.gd
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class_name Unit\nextends CharacterBody2D\n\n@export_category(\"Combat\")\n@export var attack_range := 100.0\n@export var attack_cooldown := 0.5\n@export var damage: float = 10.0\n@export var team: enums.e_team\n@export var movement_speed: float =  100.0\n\n\n@export_category(\"Animations\")\n@export var attack_animations : Dictionary = {\n\t\"front\": [],\n\t\"up\": [],\n\t\"down\": [],\n}\n\n@export var debug_individual := false\n\n@export_category(\"Misc\")\n@export var cost : Dictionary = {\n\tenums.e_resource_type.gold: 0.0,\n\tenums.e_resource_type.wood: 0.0,\n\tenums.e_resource_type.meat: 0.0,\n\tenums.e_resource_type.supply: 1\n}\n\n@export var unit_type: enums.E_UnitType\n@export_category(\"Audio\")\n@export var confirm_acks: Array[AudioStream] = []\n@export var engage_sounds : Array[AudioStream] = []\n@export var weapon_sounds : Array[AudioStream] = []\n\n\nvar _audio_streams         := []\nvar _attack_timer: Timer\nvar _auto_attack           := true\nvar _cell_block: CellBlock =  CellBlock.new(self)\n\nvar _current_cell: SelectionGridCell:\n\tget: return _current_cell\n\tset(value): _current_cell = value\n\nvar _current_cell_label: Label\nvar _current_order_type: enums.e_order_type\nvar _death_animated_sprite: AnimatedSprite2D\nvar _details\nvar _group_guid\nvar _is_attacking          := false\nvar _is_idle               := true\nvar _strike_frame_index    := 3 # the frame where the attack animation looks like it is connecting\nvar _targeted_enemy: Attackable\nvar _weapon_audio_stream   := AudioStreamPlayer2D.new()\n\n#region Node References\n@onready var _attack_area: Area2D = $AttackArea\n@onready var _attackable : Attackable = $Attackable\n@onready var _anim_sprite : AnimatedSprite2D = $AnimatedSprite2D\n@onready var _navigation_agent: NavigationAgent2D = get_node(\"NavigationAgent2D\")\n@onready var _selection_hover_area: Area2D = $SelectionHoverArea\n@onready var _vision_area: Area2D = $VisionArea\n#endregion\n\n#region Built-in Functions\nfunc _ready() -> void:\n\tz_index = Globals.unit_z_index\n\tResourceManager._update_resource(cost[enums.e_resource_type.supply], enums.e_resource_type.supply)\n\tadd_to_group(Globals.unit_group) # TODO: Is this used anymore?\n\t\n\t_setup_attack()\n\t_setup_audio_streams()\n\t_setup_signal_connections()\n\t_setup_ui_detail()\n\n\tif debug_individual or Globals.debug:\n\t\t_setup_debug_labels()\n\t\tfor c in get_children():\n\t\t\tif c is Area2D:\n\t\t\t\tvar shape: Node = c.get_child(0)\n\t\t\t\tif shape is CollisionShape2D:\n\t\t\t\tshape.visible = true\n\t\t_navigation_agent.set_debug_enabled(true)\n\t\t_navigation_agent.set_debug_use_custom(true)\n\t\t_navigation_agent.set_debug_path_custom_color(Color.MAGENTA)\n\t\t_navigation_agent.set_debug_path_custom_point_size(10)\n\t\t_navigation_agent.set_debug_path_custom_line_width(4)\n\n\telse:\n\t\tfor c in get_children():\n\t\t\tif c is Area2D:\n\t\t\t\tvar shape: Node = c.get_child(0)\n\t\t\t\tif shape is CollisionShape2D:\n\t\t\t\t\tshape.visible = false\n\tawait get_tree().process_frame\n\t_cell_block.block_cell()\n\n\n\nfunc _physics_process(_delta: float) -> void:\n\n\tif Input.is_key_pressed(KEY_T):\n\t\t_stop_attacking()\n\n\t_handle_debug_drawing()\n\t_handle_movement()\n\n\tif _attackable._is_dying:\n\t\treturn\n\n\t_handle_combat()\n\n\nfunc _handle_debug_drawing() -> void:\n\tif _current_cell != null and debug_individual:\n\t\tDebugDraw2d.rect(_current_cell.position)\n\n\nfunc _handle_combat() -> void:\n\tif _targeted_enemy == null:\n\t\treturn\n\n\tif _is_attacking:\n\t\t_update_sprite_direction(_targeted_enemy.global_position)\n\t\treturn\n\n\tif _should_move_to_enemy(_targeted_enemy):\n\t\tset_movement_target(_targeted_enemy.global_position)\n\n\nfunc _handle_movement() -> void:\n\tif _navigation_agent.is_navigation_finished():\n\t\treturn\n\n\tvar next_path_position := _navigation_agent.get_next_path_position()\n\tvar new_velocity       := global_position.direction_to(next_path_position) * movement_speed\n\n\tif _navigation_agent.avoidance_enabled:\n\t\t_navigation_agent.set_velocity(new_velocity)\n\telse:\n\t\t_on_velocity_computed(new_velocity)\n\n\tif not _is_attacking:\n\t\t_update_sprite_direction(next_path_position)\n\n#endregion\n\n#region Public Functions\nfunc can_afford_to_build() -> structs.can_afford_response:\n\tvar can_afford = structs.can_afford_response.new()\n\tfor r in cost:\n\t\tmatch r:\n\t\t\tenums.e_resource_type.gold:\n\t\t\t\tif ResourceManager.gold < cost[r]:\n\t\t\t\t\tcan_afford.reason = enums.e_cannot_build_reason.insufficient_gold\n\t\t\t\t\tbreak\n\t\t\tenums.e_resource_type.wood:\n\t\t\t\tif ResourceManager.wood < cost[r]:\n\t\t\t\t\tcan_afford.reason = enums.e_cannot_build_reason.insufficient_wood\n\t\t\t\t\tbreak\n\t\t\tenums.e_resource_type.meat:\n\t\t\t\tif ResourceManager.meat < cost[r]:\n\t\t\t\t\tcan_afford.reason = enums.e_cannot_build_reason.insufficient_meat\n\t\t\t\t\tbreak\n\t\t\tenums.e_resource_type.supply:\n\t\t\t\tif ResourceManager.supply_cap < cost[r] + ResourceManager.supply:\n\t\t\t\t\tcan_afford.reason = enums.e_cannot_build_reason.insufficient_supply\n\t\t\t\t\tbreak\n\tcan_afford.result = can_afford.reason == enums.e_cannot_build_reason.none\n\treturn can_afford\n\n\nfunc get_attackable() -> Attackable:\n\treturn _attackable\n\nfunc order_move(in_goal, in_order_type : enums.e_order_type, silent := false) -> void:\n\t_is_idle = false\n\tif _cell_block._is_blocking_cell:\n\t\t_cell_block.unblock_cell()\n\tif in_order_type != enums.e_order_type.attack:\n\t\t_disconnect_signals_on_target_change(_targeted_enemy)\n\t\t_stop_attacking()\n\t\n\t_acknowledge(silent)\n\t_anim_sprite.animation = \"run\"\n\tset_movement_target(in_goal)\n\nfunc order_attack(enemy):\n\t_disconnect_signals_on_target_change(enemy)\n\tUtil.create_one_shot_audio_stream(\"attacking_audio_stream\", engage_sounds, self)\n\n\tif enemy is CharacterBody2D:\n\t\t_targeted_enemy = enemy.get_node(\"Attackable\")\n\telse:\n\t\t_targeted_enemy = enemy\n\n\tvar result: int = _targeted_enemy.sig_dying.connect(_on_target_die)\n\n\tif result == ERR_INVALID_PARAMETER:\n\t\tpush_error(\"Invalid parameter!\")\n\n\tif (_attack_area.overlaps_area(_targeted_enemy.get_collision_area())):\n\t\t_begin_attacking()\n\telse:\n\t\torder_move(enemy.global_position, enums.e_order_type.attack, true)\n\nfunc set_in_selection(val):\n\t_attackable.set_in_selection(val)\n\nfunc stop_moving() -> void:\n\tset_movement_target(position)\n\nfunc set_movement_target(movement_target: Vector2) -> void:\n\t_navigation_agent.set_target_position(movement_target)\n\nfunc set_selection_circle_visible(new_visible) -> void:\n\t$\"Selection Circle\".visible = new_visible\n#endregion\n\n#region Private Functions\nfunc _acknowledge(silent: bool) -> void:\n\tvar acknowledger = UnitManager.group_get_acknowledger(_group_guid)\n\tif !silent and acknowledger == null or acknowledger == self:\n\t\tvar temp_stream = AudioStreamPlayer2D.new()\n\t\ttemp_stream.stream = confirm_acks[randi_range(0, len(confirm_acks) - 1)]\n\t\t_audio_streams.push_back(temp_stream)\n\t\tadd_child(temp_stream)\n\t\ttemp_stream.play()\n\t\tif _group_guid != null:\n\t\t\tUnitManager.group_set_acknowledger(_group_guid, self)\n\n\nfunc _begin_attacking() -> void:\n\tstop_moving()\n\tawait _navigation_agent.navigation_finished\n\t_is_attacking = true\n\tvar animation_name: StringName = _select_attack_animation()\n\tif _anim_sprite.sprite_frames.has_animation(animation_name):\n\t\t_anim_sprite.animation = animation_name\n\n## This assumes a lot and is not very useful in any other situation.\nfunc _can_attack_body(body) -> bool:\n\treturn (_is_idle and\n\t\t\tbody is CharacterBody2D and \n\t\t\tbody.team != team)\n\n\nfunc _check_vision_for_enemy_to_attack() -> void:\n\tfor body in _vision_area.get_overlapping_bodies():\n\t\tif (_can_attack_body(body)):\n\t\t\torder_attack(body)\n\t\t\treturn\n\n\nfunc _disconnect_signals_on_target_change(enemy) -> void:\n\tif _targeted_enemy == null:\n\t\treturn\n\n\tif _targeted_enemy.sig_dying.is_connected(_on_target_die):\n\t\t_targeted_enemy.sig_dying.disconnect(_on_target_die)\n\n\nfunc _should_move_to_enemy(enemy) -> bool:\n\treturn enemy != null and _vision_area.overlaps_area(enemy) and !_is_attacking\n\n\nfunc _update_sprite_direction(target_position: Vector2) -> void:\n\tvar is_facing_left := global_position.direction_to(target_position).dot(Vector2.RIGHT) < 0\n\t_anim_sprite.flip_h = is_facing_left\n\n\n## You have to pass in the correct amount of StringNames in the anims array\n## i.e. if the amount of rows in the full spritesheet is 2 then you need to pass\n## 2 StringNames in the anims array\nfunc _extract_sprite_frames(anims: Array[StringName], \n\t\ttexture_size: Vector2, \n\t\tsprite_size: Vector2, \n\t\tfull_spritesheet: Texture2D) -> Array[SpriteFrames]:\n\tvar sprite_frames_list : Array[SpriteFrames]\n\tvar num_cols := int(texture_size.x / sprite_size.x)\n\tvar num_rows := int(texture_size.y / sprite_size.y)\n\t\n\tfor y in range(num_rows):\n\t\tif y >= anims.size():\n\t\t\tbreak\n\t\t\n\t\tvar sprite_frames = SpriteFrames.new()\n\t\tsprite_frames.add_animation(anims[y])\n\t\tfor x in range(num_cols):\n\t\t\tvar frame_tex := AtlasTexture.new()\n\t\t\tframe_tex.atlas = full_spritesheet\n\t\t\tframe_tex.region = Rect2(Vector2(x, y) * sprite_size, sprite_size)\n\t\t\tsprite_frames.add_frame(anims[y], frame_tex, 1, y * num_cols + x)\n\t\tsprite_frames_list.append(sprite_frames)\n\t\n\treturn sprite_frames_list\n\n\nfunc _find_close_in_group_units_and_stop_them() -> void:\n\tfor a in $SearchAreaSmall.get_overlapping_areas():\n\t\tif a.owner == null:\n\t\t\tcontinue\n\t\tif a.owner.is_in_group(Globals.unit_group):\n\t\t\tvar unit = a.owner as Unit\n\t\tif UnitManager.groups.has(_group_guid) and unit._group_guid == _group_guid:\n\t\t\t\tunit.stop()\n\tUnitManager.groups[_group_guid].group_stopping = false\n\n\nfunc _select_attack_animation() -> StringName:\n\tif len(attack_animations[\"up\"]) == 0 or _targeted_enemy == null:\n\t\treturn &\"\"\n\t\n\tvar attack_animation := &\"\"\n\tvar _unit_to_enemy   =  global_position.direction_to(_targeted_enemy.global_position)\n\tvar _up_dot_unit_to_enemy = _unit_to_enemy.dot(Vector2.UP)\n\tvar _right_dot_unit_to_enemy = _unit_to_enemy.dot(Vector2.RIGHT)\n\t\n\t# up or down takes over\n\tif abs(_up_dot_unit_to_enemy) > abs(_right_dot_unit_to_enemy):\n\t\tif _up_dot_unit_to_enemy > 0:\n\t\t\tattack_animation = attack_animations[\"up\"][0]\n\t\telse:\n\t\t\tattack_animation = attack_animations[\"down\"][0]\n\telse:\n\t\tattack_animation = attack_animations[\"front\"][0]\n\t\tif _right_dot_unit_to_enemy > 0:\n\t\t\t_anim_sprite.flip_h = false\n\t\telse:\n\t\t\t_anim_sprite.flip_h = true\n\t\n\treturn attack_animation\n\n\nfunc _stop_attacking() -> void:\n\t_targeted_enemy = null\n\t_is_attacking = false\n\t_attack_timer.stop()\n\t_anim_sprite.animation = \"idle\"\n\tstop_moving()\n#endregion\n\n#region Listeners\nfunc _on_anim_frame_changed() -> void:\n\tif !_is_attacking:\n\t\treturn\n\t\n\t#check when we are rearing back if the target is dead\n\tif _anim_sprite.frame < _strike_frame_index:\n\t\tif _targeted_enemy == null or _targeted_enemy.is_queued_for_deletion():\n\t\t\t_stop_attacking()\n\telif _anim_sprite.frame == _strike_frame_index:\n\t\t_on_attack()\n\n\nfunc _on_attack_area_body_entered(body: Node2D) -> void:\n\tif  !body.has_node(\"Attackable\") or body.team == team:\n\t\t#print(\"cannot attack them though\")\n\t\treturn\n\tstop_moving()\n\tawait _navigation_agent.navigation_finished\n\t_begin_attacking()\n\n\n\nfunc _on_attack_area_body_exited(body: Node2D) -> void:\n\tvar unit: Unit = body as Unit\n\tif unit == null:\n\t\treturn\n\n\tif unit.get_attackable() != _targeted_enemy or _targeted_enemy == null or _attackable.get_is_dying():\n\t\treturn\n\n\tvar target_cache: Attackable = _targeted_enemy\n\t_stop_attacking()\n\n\n#if !target_cache._is_dying:\n#order_attack(target_cache)\n\nfunc _on_attack() -> void:\n\t_weapon_audio_stream.stream = weapon_sounds[randi_range(0, weapon_sounds.size() - 1)]\n\t_weapon_audio_stream.play()\n\t_targeted_enemy.take_damage(damage)\n\nfunc _on_mouse_overlap() -> void:\n\tSelectionHandler.mouse_hovered_unit = self #TODO: stop directly setting this\n\nfunc _on_mouse_exit() -> void:\n\tif SelectionHandler.mouse_hovered_unit == self:\n\t\tSelectionHandler.mouse_hovered_unit = null\n\nfunc _on_navigation_finished() -> void:\n\t_cell_block.block_cell()\n\t_is_idle = true\n\t_anim_sprite.animation = \"idle\"\n\tif _targeted_enemy == null and _auto_attack:\n\t\t_check_vision_for_enemy_to_attack()\n\nfunc _on_target_die(target) -> void:\n\tassert (target == _targeted_enemy)\n\t_targeted_enemy.sig_dying.disconnect(_on_target_die)\n\t_stop_attacking()\n\nfunc _on_vision_area_body_entered(body) -> void:\n\tif _can_attack_body(body) and _auto_attack:\n\t\torder_attack(body)\n\nfunc _on_vision_area_body_exited(body) -> void:\n\tif body == _targeted_enemy:\n\t\tassert(!(self is Worker))\n\t\t_stop_attacking()\n\t\t_check_vision_for_enemy_to_attack()\n\nfunc _on_velocity_computed(safe_velocity: Vector2) -> void:\n\tvelocity = safe_velocity\n\tmove_and_slide()\n#endregion\n\n#region Setup\nfunc _setup_attack() -> void:\n\tfor anim_name in _anim_sprite.sprite_frames.get_animation_names():\n\t\tif Globals.has_pattern(\"down.*attack\", anim_name):\n\t\t\tattack_animations[\"down\"].append(anim_name)\n\t\telif Globals.has_pattern(\"front.*attack\", anim_name):\n\t\t\tattack_animations[\"front\"].append(anim_name)\n\t\telif Globals.has_pattern(\"up.*attack\", anim_name):\n\t\t\tattack_animations[\"up\"].append(anim_name)\n\t\n\t# setup attack area collision shape radius\n\tvar attack_area_collision_shape = _attack_area.get_child(0) \n\tattack_area_collision_shape.shape.radius = attack_range\n\t\n\t_attack_timer = Timer.new()\n\t_attack_timer.wait_time = attack_cooldown\n\t_attack_timer.timeout.connect(_on_attack)\n\tadd_child(_attack_timer)\n\nfunc _setup_audio_streams() -> void:\n\tadd_child(_weapon_audio_stream)\n\tweapon_sounds.append(load(\"res://sound/Minifantasy_Weapons_SFX/Slash_Attacks/Slash_Attack_Sword_1.wav\"))\n\tweapon_sounds.append(load(\"res://sound/Minifantasy_Weapons_SFX/Slash_Attacks/Slash_Attack_Sword_2.wav\"))\n\tweapon_sounds.append(load(\"res://sound/Minifantasy_Weapons_SFX/Slash_Attacks/Slash_Attack_Sword_3.wav\"))\n\t\n\tconfirm_acks.append(load(\"res://sound/LEOHPAZ_Command_Speech/Human/Human_Confirm_1.wav\"))\n\tconfirm_acks.append(load(\"res://sound/LEOHPAZ_Command_Speech/Human/Human_Confirm_2.wav\"))\n\tconfirm_acks.append(load(\"res://sound/LEOHPAZ_Command_Speech/Human/Human_Confirm_3.wav\"))\n\t\n\tvar clean_timer = Timer.new()\n\tclean_timer.wait_time = .5\n\tclean_timer.timeout.connect(func(): \n\t\tvar stream = _audio_streams.pop_back()\n\t\tif stream != null and !stream.is_queued_for_deletion() and !stream.playing:\n\t\t\tstream.queue_free()\n\t\telif stream != null:\n\t\t\t_audio_streams.push_back(stream)\n\t)\n\tadd_child(clean_timer)\n\tclean_timer.start()\n\n# not good for death animation but could be good for another animation type maybe\nfunc _setup_death_animated_sprite() -> void:\n\t_death_animated_sprite = AnimatedSprite2D.new()\n\t_death_animated_sprite.name = &\"DeathAnimatedSprite_FromCode\"\n\t\n\tvar texture_size := Vector2(896, 256)\n\tvar sprite_size := Vector2(128, 128)\n\tvar full_spritesheet : Texture = load(\"res://art/Tiny Swords (Update 010)/Factions/Knights/Troops/Dead/Dead.png\")\n\tvar sprite_frames_array : Array[SpriteFrames] = _extract_sprite_frames([&\"die\"], texture_size, sprite_size, full_spritesheet)\n\t\n\tsprite_frames_array[0].set_animation_speed(&\"die\", 10)\n\tsprite_frames_array[0].set_animation_loop(&\"die\", false)\n\t\n\t_death_animated_sprite.sprite_frames = sprite_frames_array[0]\n\tadd_child(_death_animated_sprite)\n\nfunc _setup_debug_labels() -> void:\n\t# Debug name text\n\tvar label = Label.new()\n\tlabel.text = \"%s\" % name\n\tadd_child(label)\n\tlabel.position = Vector2(0, -100) # is relative pos\n\t\n\t# debug current cell text\n\t_current_cell_label = Label.new()\n\tadd_child(_current_cell_label)\n\t_current_cell_label.position = Vector2(0, 25) # is relative pos\n\nfunc _setup_signal_connections() -> void:\n\t_anim_sprite.frame_changed.connect(_on_anim_frame_changed)\n\t_attack_area.body_entered.connect(_on_attack_area_body_entered)\n\t_attack_area.body_exited.connect(_on_attack_area_body_exited)\n\t_navigation_agent.navigation_finished.connect(_on_navigation_finished)\n\t_navigation_agent.velocity_computed.connect(Callable(_on_velocity_computed))\n\t_selection_hover_area.mouse_entered.connect(_on_mouse_overlap)\n\t_selection_hover_area.mouse_exited.connect(_on_mouse_exit)\n\t_vision_area.body_entered.connect(_on_vision_area_body_entered)\n\t_vision_area.body_exited.connect(_on_vision_area_body_exited)\n\nfunc _setup_ui_detail() -> void:\n\tvar ui_detail_one = UI_Detail.new()\n\tui_detail_one.image_one_path = \"res://art/icons/RPG Graphics Pack - Icons/Pack 1A-Renamed/boot/boot_03.png\"\n\tui_detail_one.detail_one = movement_speed\n\tvar unit_picture_path = \"res://art/Tiny Swords (Update 010)/Factions/Knights/Troops/Pawn/Blue/Pawn_Blue-still.png\"\n\t_details = [ui_detail_one, unit_picture_path]\n#endregion\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/units/unit.gd b/scripts/units/unit.gd
--- a/scripts/units/unit.gd	(revision 157b44057eb71e839345f6225860b1978eb187d9)
+++ b/scripts/units/unit.gd	(date 1749931005619)
@@ -64,7 +64,7 @@
 
 #region Built-in Functions
 func _ready() -> void:
-	z_index = Globals.unit_z_index
+	z_index = Globals.default_z_index
 	ResourceManager._update_resource(cost[enums.e_resource_type.supply], enums.e_resource_type.supply)
 	add_to_group(Globals.unit_group) # TODO: Is this used anymore?
 	
@@ -79,7 +79,7 @@
 			if c is Area2D:
 				var shape: Node = c.get_child(0)
 				if shape is CollisionShape2D:
-				shape.visible = true
+					shape.visible = true
 		_navigation_agent.set_debug_enabled(true)
 		_navigation_agent.set_debug_use_custom(true)
 		_navigation_agent.set_debug_path_custom_color(Color.MAGENTA)
@@ -179,7 +179,8 @@
 		_cell_block.unblock_cell()
 	if in_order_type != enums.e_order_type.attack:
 		_disconnect_signals_on_target_change(_targeted_enemy)
-		_stop_attacking()
+		if _is_attacking:
+			_stop_attacking()
 	
 	_acknowledge(silent)
 	_anim_sprite.animation = "run"
@@ -301,8 +302,8 @@
 		if a.owner == null:
 			continue
 		if a.owner.is_in_group(Globals.unit_group):
-			var unit = a.owner as Unit
-		if UnitManager.groups.has(_group_guid) and unit._group_guid == _group_guid:
+			var unit: Unit = a.owner as Unit
+			if UnitManager.groups.has(_group_guid) and unit._group_guid == _group_guid:
 				unit.stop()
 	UnitManager.groups[_group_guid].group_stopping = false
 
@@ -333,11 +334,10 @@
 
 
 func _stop_attacking() -> void:
-	_targeted_enemy = null
 	_is_attacking = false
 	_attack_timer.stop()
 	_anim_sprite.animation = "idle"
-	stop_moving()
+	
 #endregion
 
 #region Listeners
@@ -357,8 +357,6 @@
 	if  !body.has_node("Attackable") or body.team == team:
 		#print("cannot attack them though")
 		return
-	stop_moving()
-	await _navigation_agent.navigation_finished
 	_begin_attacking()
 
 
